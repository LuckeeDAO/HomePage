<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rust智能合约开发指南</title>
    <style>
        body {
            max-width: 860px;
            margin: 32px auto;
            padding: 0 16px;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            line-height: 1.6;
            color: #1f2937;
        }
        pre { background:#f8fafc; padding:12px; overflow:auto; border-radius:6px; }
        code { background:#f1f5f9; padding:2px 4px; border-radius:4px; }
        h1,h2,h3,h4,h5,h6 { line-height:1.25; }
        a { color:#2563eb; text-decoration:none; }
        a:hover { text-decoration:underline; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #e5e7eb; padding: 8px; }
        blockquote { margin: 0; padding-left: 1em; border-left: 4px solid #e5e7eb; color:#6b7280; }
    </style>
</head>
<body>
<h1>Rust智能合约开发指南</h1>
<br/>
<h2>概述</h2>
<br/>
<p>本指南详细介绍如何使用Rust语言和CosmWasm框架开发去中心化投票系统的智能合约。架构边界：</p>
<p>- 投票项目管理是NFT管理的属性接口，配置均为NFT类型的全局参数；</p>
<p>- 详细投票数据（承诺/揭示明细、计算过程、参与者列表、证明等）存储在IPFS；</p>
<p>- 链上仅记录账户与NFT的关联信息以及结果摘要/哈希/CID与必要索引。</p>
<br/>
<h2>技术栈</h2>
<br/>
<p>- **开发语言**：Rust</p>
<p>- **智能合约框架**：CosmWasm</p>
<p>- **区块链平台**：Injective Protocol</p>
<p>- **开发工具**：cargo, wasm-pack, cosmwasm-check</p>
<br/>
<h2>环境搭建</h2>
<br/>
<h3>1. 安装Rust</h3>
<pre><code>
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
rustup default stable
</code></pre>
<br/>
<h3>2. 安装CosmWasm工具链</h3>
<pre><code>
# 安装wasm-pack
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# 安装cosmwasm-check
cargo install cosmwasm-check

# 安装wasm-opt (可选，用于优化)
cargo install wasm-opt
</code></pre>
<br/>
<h3>3. 创建项目</h3>
<pre><code>
# 创建新的CosmWasm项目
cargo generate --git https://github.com/CosmWasm/cw-template.git --name decision-voting-contract
cd decision-voting-contract
</code></pre>
<br/>
<h2>项目结构</h2>
<br/>
<pre><code>
decision-voting-contract/
├── Cargo.toml                 # 项目配置
├── src/
│   ├── contract.rs            # 合约入口点
│   ├── msg.rs                 # 消息定义
│   ├── state.rs               # 状态定义
│   ├── error.rs               # 错误处理
│   └── lib.rs                 # 库入口
├── schema/                    # JSON Schema生成
├── tests/                     # 测试文件
└── examples/                  # 示例代码
</code></pre>
<br/>
<h2>核心组件</h2>
<br/>
<h3>1. 消息定义 (msg.rs)</h3>
<br/>
<pre><code>
use cosmwasm_std::{Addr, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    CreateDecisionVote {
        title: String,
        description: String,
        min_preference: i32,
        max_preference: i32,
        start_time: u64,
        end_time: u64,
        max_votes: Option&lt;u64&gt;,
        min_votes: Option&lt;u64&gt;,
        is_lottery: bool,
        nft_type: String,                     // NFT类型标识（作为投票项目属性接口的承载）
        config_cid: String,                   // IPFS上完整配置版本的CID（链上仅存指针）
    },
    SubmitPreferenceCommitment {
        decision_vote_id: String,
        commitment_hash: String,              // 承诺哈希（明细存IPFS）
        nft_type: String,
    },
    RevealPreferenceVote {
        decision_vote_id: String,
        preference: i32,
        randomness: String,
        nft_type: String,                     // NFT类型
    },
    // NFT类型管理
    CreateNFTType {
        nft_type: String,
        config: NFTTypeConfig,
        state_schema: StateSchema,
    },
    UpdateNFTState {
        nft_type: String,
        variable_name: String,
        new_value: StateValue,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    GetDecisionVote { decision_vote_id: String },
    GetPreferenceCommitments { decision_vote_id: String },
    CalculateDecisionResult { decision_vote_id: String },
    CalculateLotteryResult { decision_vote_id: String },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
    pub admin: Option&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}
</code></pre>
<br/>
<h3>2. 状态定义 (state.rs)</h3>
<br/>
<pre><code>
use cosmwasm_std::{Addr, Storage};
use cosmwasm_storage::{bucket, bucket_read, Bucket, ReadonlyBucket};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct DecisionVote {
    pub title: String,
    pub description: String,
    pub min_preference: i32,
    pub max_preference: i32,
    pub start_time: u64,
    pub end_time: u64,
    pub max_votes: Option&lt;u64&gt;,
    pub min_votes: Option&lt;u64&gt;,
    pub is_active: bool,
    pub result_hash: String,
    pub creator: Addr,
    pub is_lottery: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct PreferenceVoteCommitment {
    pub commitment: String,
    pub timestamp: u64,
    pub decision_maker: Addr,
    pub is_revealed: bool,
}

// 存储键定义
pub const DECISION_VOTES: &amp;[u8] = b"decision_votes";
pub const COMMITMENTS: &amp;[u8] = b"commitments";
pub const VOTE_COUNTS: &amp;[u8] = b"vote_counts";
pub const PREFERENCE_SUMS: &amp;[u8] = b"preference_sums";
pub const LOTTERY_RESULTS: &amp;[u8] = b"lottery_results";

// 存储函数
pub fn decision_votes(storage: &amp;mut dyn Storage) -&gt; Bucket&lt;DecisionVote&gt; {
    bucket(storage, DECISION_VOTES)
}

pub fn decision_votes_read(storage: &amp;dyn Storage) -&gt; ReadonlyBucket&lt;DecisionVote&gt; {
    bucket_read(storage, DECISION_VOTES)
}

pub fn commitments(storage: &amp;mut dyn Storage) -&gt; Bucket&lt;PreferenceVoteCommitment&gt; {
    bucket(storage, COMMITMENTS)
}

pub fn commitments_read(storage: &amp;dyn Storage) -&gt; ReadonlyBucket&lt;PreferenceVoteCommitment&gt; {
    bucket_read(storage, COMMITMENTS)
}

pub fn vote_counts(storage: &amp;mut dyn Storage) -&gt; Bucket&lt;u64&gt; {
    bucket(storage, VOTE_COUNTS)
}

pub fn vote_counts_read(storage: &amp;dyn Storage) -&gt; ReadonlyBucket&lt;u64&gt; {
    bucket_read(storage, VOTE_COUNTS)
}

pub fn preference_sums(storage: &amp;mut dyn Storage) -&gt; Bucket&lt;i64&gt; {
    bucket(storage, PREFERENCE_SUMS)
}

pub fn preference_sums_read(storage: &amp;dyn Storage) -&gt; ReadonlyBucket&lt;i64&gt; {
    bucket_read(storage, PREFERENCE_SUMS)
}

pub fn lottery_results(storage: &amp;mut dyn Storage) -&gt; Bucket&lt;u64&gt; {
    bucket(storage, LOTTERY_RESULTS)
}

pub fn lottery_results_read(storage: &amp;dyn Storage) -&gt; ReadonlyBucket&lt;u64&gt; {
    bucket_read(storage, LOTTERY_RESULTS)
}
</code></pre>
<br/>
<h3>3. 错误处理 (error.rs)</h3>
<br/>
<pre><code>
use cosmwasm_std::StdError;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error("{0}")]
    Std(#[from] StdError),

    #[error("Invalid preference range")]
    InvalidPreferenceRange,

    #[error("Voting not started")]
    VotingNotStarted,

    #[error("Voting ended")]
    VotingEnded,

    #[error("Decision vote not active")]
    DecisionVoteNotActive,

    #[error("Already voted")]
    AlreadyVoted,

    #[error("No commitment found")]
    NoCommitmentFound,

    #[error("Already revealed")]
    AlreadyRevealed,

    #[error("Invalid commitment")]
    InvalidCommitment,

    #[error("Preference out of range")]
    PreferenceOutOfRange,

    #[error("Not a lottery")]
    NotALottery,

    #[error("No participants")]
    NoParticipants,

    #[error("Decision vote not found")]
    DecisionVoteNotFound,
}
</code></pre>
<br/>
<h3>4. 合约实现 (contract.rs)</h3>
<br/>
<pre><code>
use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, Env, MessageInfo,
    Response, StdResult, Addr, StdError,
};

use crate::error::ContractError;
use crate::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};
use crate::state::*;
use crate::crypto::*;

#[entry_point]
pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    Ok(Response::new().add_attribute("method", "instantiate"))
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    match msg {
        ExecuteMsg::CreateDecisionVote { title, description, min_preference, max_preference, start_time, end_time, max_votes, min_votes, is_lottery } =&gt; {
            execute_create_decision_vote(deps, env, info, title, description, min_preference, max_preference, start_time, end_time, max_votes, min_votes, is_lottery)
        }
        ExecuteMsg::SubmitPreferenceCommitment { decision_vote_id, commitment } =&gt; {
            execute_submit_preference_commitment(deps, env, info, decision_vote_id, commitment)
        }
        ExecuteMsg::RevealPreferenceVote { decision_vote_id, preference, randomness } =&gt; {
            execute_reveal_preference_vote(deps, env, info, decision_vote_id, preference, randomness)
        }
    }
}

#[entry_point]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    match msg {
        QueryMsg::GetDecisionVote { decision_vote_id } =&gt; {
            to_binary(&amp;query_decision_vote(deps, decision_vote_id)?)
        }
        QueryMsg::GetPreferenceCommitments { decision_vote_id } =&gt; {
            to_binary(&amp;query_preference_commitments(deps, decision_vote_id)?)
        }
        QueryMsg::CalculateDecisionResult { decision_vote_id } =&gt; {
            to_binary(&amp;query_calculate_decision_result(deps, decision_vote_id)?)
        }
        QueryMsg::CalculateLotteryResult { decision_vote_id } =&gt; {
            to_binary(&amp;query_calculate_lottery_result(deps, decision_vote_id)?)
        }
    }
}

#[entry_point]
pub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::default())
}

// 实现具体的执行函数
pub fn execute_create_decision_vote(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    title: String,
    description: String,
    min_preference: i32,
    max_preference: i32,
    start_time: u64,
    end_time: u64,
    max_votes: Option&lt;u64&gt;,
    min_votes: Option&lt;u64&gt;,
    is_lottery: bool,
) -&gt; Result&lt;Response, ContractError&gt; {
    // 验证输入参数
    if min_preference &gt;= max_preference {
        return Err(ContractError::InvalidPreferenceRange);
    }
    if start_time &lt;= env.block.time.seconds() {
        return Err(ContractError::VotingNotStarted);
    }
    if end_time &lt;= start_time {
        return Err(ContractError::Std(StdError::generic_err("End time must be after start time")));
    }
    
    // 生成决策投票ID
    let decision_vote_id = generate_decision_vote_id(&amp;title, &amp;description, &amp;env.block.time.seconds(), &amp;info.sender);
    
    // 创建决策投票
    let decision_vote = DecisionVote {
        title,
        description,
        min_preference,
        max_preference,
        start_time,
        end_time,
        max_votes,
        min_votes,
        is_active: true,
        result_hash: String::new(),
        creator: info.sender.clone(),
        is_lottery,
    };
    
    // 保存到存储
    decision_votes(deps.storage).save(decision_vote_id.as_bytes(), &amp;decision_vote)?;
    
    Ok(Response::new()
        .add_attribute("action", "create_decision_vote")
        .add_attribute("decision_vote_id", decision_vote_id)
        .add_attribute("creator", info.sender.to_string()))
}

pub fn execute_submit_preference_commitment(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    decision_vote_id: String,
    commitment: String,
) -&gt; Result&lt;Response, ContractError&gt; {
    // 获取决策投票
    let decision_vote = decision_votes_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .map_err(|_| ContractError::DecisionVoteNotFound)?;
    
    // 验证投票状态
    if !decision_vote.is_active {
        return Err(ContractError::DecisionVoteNotActive);
    }
    if env.block.time.seconds() &lt; decision_vote.start_time {
        return Err(ContractError::VotingNotStarted);
    }
    if env.block.time.seconds() &gt; decision_vote.end_time {
        return Err(ContractError::VotingEnded);
    }
    
    // 检查是否已经投票
    let commitment_key = format!("{}:{}", decision_vote_id, info.sender);
    if commitments_read(deps.storage).load(commitment_key.as_bytes()).is_ok() {
        return Err(ContractError::AlreadyVoted);
    }
    
    // 创建承诺
    let commitment_data = PreferenceVoteCommitment {
        commitment,
        timestamp: env.block.time.seconds(),
        decision_maker: info.sender.clone(),
        is_revealed: false,
    };
    
    // 保存承诺
    commitments(deps.storage).save(commitment_key.as_bytes(), &amp;commitment_data)?;
    
    // 更新投票计数
    let current_count = vote_counts_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .unwrap_or(0);
    vote_counts(deps.storage).save(decision_vote_id.as_bytes(), &amp;(current_count + 1))?;
    
    Ok(Response::new()
        .add_attribute("action", "submit_preference_commitment")
        .add_attribute("decision_vote_id", decision_vote_id)
        .add_attribute("decision_maker", info.sender.to_string())
        .add_attribute("commitment", commitment))
}

pub fn execute_reveal_preference_vote(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    decision_vote_id: String,
    preference: i32,
    randomness: String,
) -&gt; Result&lt;Response, ContractError&gt; {
    // 获取决策投票
    let decision_vote = decision_votes_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .map_err(|_| ContractError::DecisionVoteNotFound)?;
    
    // 验证投票状态
    if !decision_vote.is_active {
        return Err(ContractError::DecisionVoteNotActive);
    }
    if env.block.time.seconds() &lt;= decision_vote.end_time {
        return Err(ContractError::Std(StdError::generic_err("Voting not ended")));
    }
    
    // 获取承诺
    let commitment_key = format!("{}:{}", decision_vote_id, info.sender);
    let mut commitment = commitments(deps.storage)
        .load(commitment_key.as_bytes())
        .map_err(|_| ContractError::NoCommitmentFound)?;
    
    // 验证承诺
    if commitment.is_revealed {
        return Err(ContractError::AlreadyRevealed);
    }
    if preference &lt; decision_vote.min_preference || preference &gt; decision_vote.max_preference {
        return Err(ContractError::PreferenceOutOfRange);
    }
    
    // 验证承诺的正确性
    let computed_commitment = compute_commitment(preference, &amp;randomness);
    if computed_commitment != commitment.commitment {
        return Err(ContractError::InvalidCommitment);
    }
    
    // 更新承诺状态
    commitment.is_revealed = true;
    commitments(deps.storage).save(commitment_key.as_bytes(), &amp;commitment)?;
    
    // 更新偏好值汇总
    let current_sum = preference_sums_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .unwrap_or(0);
    preference_sums(deps.storage).save(decision_vote_id.as_bytes(), &amp;(current_sum + preference))?;
    
    Ok(Response::new()
        .add_attribute("action", "reveal_preference_vote")
        .add_attribute("decision_vote_id", decision_vote_id)
        .add_attribute("decision_maker", info.sender.to_string())
        .add_attribute("preference", preference.to_string()))
}

// 查询函数实现
pub fn query_decision_vote(deps: Deps, decision_vote_id: String) -&gt; StdResult&lt;DecisionVote&gt; {
    decision_votes_read(deps.storage).load(decision_vote_id.as_bytes())
}

pub fn query_preference_commitments(deps: Deps, decision_vote_id: String) -&gt; StdResult&lt;Vec&lt;PreferenceVoteCommitment&gt;&gt; {
    // 实现获取所有承诺的逻辑
    Ok(vec![])
}

pub fn query_calculate_decision_result(deps: Deps, decision_vote_id: String) -&gt; StdResult&lt;i64&gt; {
    preference_sums_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .map_err(|_| StdError::generic_err("Decision vote not found"))
}

pub fn query_calculate_lottery_result(deps: Deps, decision_vote_id: String) -&gt; StdResult&lt;u64&gt; {
    let decision_vote = decision_votes_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .map_err(|_| StdError::generic_err("Decision vote not found"))?;
    
    if !decision_vote.is_lottery {
        return Err(StdError::generic_err("Not a lottery"));
    }
    
    let vote_count = vote_counts_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .unwrap_or(0);
    
    if vote_count == 0 {
        return Err(StdError::generic_err("No participants"));
    }
    
    let preference_sum = preference_sums_read(deps.storage)
        .load(decision_vote_id.as_bytes())
        .unwrap_or(0);
    
    let winner_index = (preference_sum.unsigned_abs() as u64) % vote_count;
    
    // 保存抽奖结果
    lottery_results(deps.storage).save(decision_vote_id.as_bytes(), &amp;winner_index)?;
    
    Ok(winner_index)
}
</code></pre>
<br/>
<h3>5. 密码学模块 (crypto.rs)</h3>
<br/>
<pre><code>
use sha2::{Sha256, Digest};

pub fn generate_decision_vote_id(title: &amp;str, description: &amp;str, timestamp: &amp;u64, sender: &amp;str) -&gt; String {
    let mut hasher = Sha256::new();
    hasher.update(title.as_bytes());
    hasher.update(description.as_bytes());
    hasher.update(timestamp.to_string().as_bytes());
    hasher.update(sender.as_bytes());
    format!("{:x}", hasher.finalize())
}

pub fn compute_commitment(preference: i32, randomness: &amp;str) -&gt; String {
    let mut hasher = Sha256::new();
    hasher.update(preference.to_string().as_bytes());
    hasher.update(randomness.as_bytes());
    format!("{:x}", hasher.finalize())
}
</code></pre>
<br/>
<h2>构建和测试</h2>
<br/>
<h3>1. 构建合约</h3>
<pre><code>
# 构建优化版本
cargo wasm

# 检查合约
cosmwasm-check target/wasm32-unknown-unknown/release/decision_voting_contract.wasm

# 优化WASM文件
wasm-opt -Os target/wasm32-unknown-unknown/release/decision_voting_contract.wasm -o target/wasm32-unknown-unknown/release/decision_voting_contract_optimized.wasm
</code></pre>
<br/>
<h3>2. 运行测试</h3>
<pre><code>
# 运行所有测试
cargo test

# 运行特定测试
cargo test test_create_decision_vote

# 生成测试覆盖率报告
cargo tarpaulin --out Html
</code></pre>
<br/>
<h3>3. 生成Schema</h3>
<pre><code>
# 生成JSON Schema
cargo schema
</code></pre>
<br/>
<h2>部署指南</h2>
<br/>
<h3>1. 本地测试网</h3>
<pre><code>
# 启动本地测试网
injectived start --chain-id=testnet

# 部署合约
injectived tx wasm store target/wasm32-unknown-unknown/release/decision_voting_contract_optimized.wasm \
  --from=mykey \
  --chain-id=testnet \
  --gas=auto \
  --gas-adjustment=1.3 \
  --yes
</code></pre>
<br/>
<h3>2. 测试网部署</h3>
<pre><code>
# 部署到Injective测试网
injectived tx wasm store target/wasm32-unknown-unknown/release/decision_voting_contract_optimized.wasm \
  --from=mykey \
  --chain-id=injective-888 \
  --gas=auto \
  --gas-adjustment=1.3 \
  --yes
</code></pre>
<br/>
<h2>最佳实践</h2>
<br/>
<h3>1. 代码组织</h3>
<p>- 使用模块化设计，分离关注点</p>
<p>- 实现清晰的错误处理</p>
<p>- 添加详细的文档注释</p>
<p>- 使用类型安全的API</p>
<br/>
<h3>2. 安全考虑</h3>
<p>- 验证所有输入参数</p>
<p>- 实现适当的访问控制</p>
<p>- 使用安全的随机数生成</p>
<p>- 防止重入攻击</p>
<p>- 实现权限管理和审计日志</p>
<br/>
<h3>3. Gas优化</h3>
<p>- 优化存储布局</p>
<p>- 减少不必要的计算</p>
<p>- 使用批量操作</p>
<p>- 实现缓存机制</p>
<br/>
<h3>4. 测试策略</h3>
<p>- 单元测试覆盖核心逻辑</p>
<p>- 集成测试验证端到端流程</p>
<p>- 压力测试验证性能</p>
<p>- 安全测试检查漏洞</p>
<p>- 边界条件测试和异常处理</p>
<br/>
<h2>常见问题</h2>
<br/>
<h2>评估标准与结论</h2>
<br/>
<h3>评估标准（统一口径）</h3>
<p>- 接口一致性：与概要/详设中消息与状态结构一致；SoT与链上最小化边界清晰。</p>
<p>- 安全性：输入校验、权限控制、重放与重入防护齐备。</p>
<p>- 可维护性：模块划分清晰、Schema齐全、测试覆盖充分。</p>
<p>- 可运维性：事件日志完整、错误可诊断、版本迁移机制。</p>
<br/>
<h3>结论</h3>
<p>合约开发规范与实现路径明确，满足安全与可维护要求，建议按本指南推进实现与审计。</p>
<br/>
<h3>1. 编译错误</h3>
<pre><code>
# 检查Rust版本
rustc --version

# 更新依赖
cargo update

# 清理缓存
cargo clean
</code></pre>
<br/>
<h3>2. 部署失败</h3>
<pre><code>
# 检查合约大小
ls -la target/wasm32-unknown-unknown/release/*.wasm

# 验证合约格式
cosmwasm-check target/wasm32-unknown-unknown/release/*.wasm

# 检查Gas限制
injectived query gas-prices
</code></pre>
<br/>
<h3>3. 测试失败</h3>
<pre><code>
# 检查测试环境
cargo test --verbose

# 运行特定测试
cargo test test_name -- --nocapture

# 检查测试依赖
cargo test --no-default-features
</code></pre>
<br/>
<h2>参考资料</h2>
<br/>
<p>- [CosmWasm官方文档](https://docs.cosmwasm.com/)</p>
<p>- [Rust编程语言](https://www.rust-lang.org/)</p>
<p>- [Injective Protocol文档](https://docs.injective.network/)</p>
<p>- [WebAssembly](https://webassembly.org/)</p>
<br/>
<p>---</p>
<br/>
<p>**开发指南版本**：1.0</p>
<p>**最后更新**：2024年12月</p>
<p>**维护人员**：技术团队</p>
<br/>
<p>---</p>
<br/>
<p>**文档编制日期**：2025年8月</p>
<p>**文档编制人**：luckeeDAO技术评估团队</p>
<p>**文档审核人**：luckeeDAO管理委员会</p>
</body>
</html>
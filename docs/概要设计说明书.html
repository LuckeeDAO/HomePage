<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>概要设计说明书</title>
    <style>
        body {
            max-width: 860px;
            margin: 32px auto;
            padding: 0 16px;
            font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            line-height: 1.6;
            color: #1f2937;
        }
        pre { background:#f8fafc; padding:12px; overflow:auto; border-radius:6px; }
        code { background:#f1f5f9; padding:2px 4px; border-radius:4px; }
        h1,h2,h3,h4,h5,h6 { line-height:1.25; }
        a { color:#2563eb; text-decoration:none; }
        a:hover { text-decoration:underline; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #e5e7eb; padding: 8px; }
        blockquote { margin: 0; padding-left: 1em; border-left: 4px solid #e5e7eb; color:#6b7280; }
    </style>
</head>
<body>
<p>﻿# 基于比特承诺模型的去中心化投票系统概要设计说明书</p>
<p>> 用词规范：请参阅《[项目术语表](项目术语表.md)》以确保术语统一。</p>
<br/>
<h2>1. 系统概述</h2>
<br/>
<h3>1.1 设计目标</h3>
<p>构建一个高性能、安全、可扩展的去中心化决策投票系统，通过比特承诺协议实现隐私保护，利用区块链技术确保数据不可篡改，支持百万级决策人规模。系统确保决策结果不依赖任何个人或部分人，包含全体决策人的偏好汇总，任何一个人的偏好投票都会影响最终结果。</p>
<br/>
<p>系统功能目标：</p>
<p>- 实现基于$LUCKEE代币持有量的权限控制</p>
<p>- **实现通过NFT类型控制不同应用场景的机制**</p>
<p>- **实现NFT分发替代用户注册功能**</p>
<p>- **实现NFT全局状态变量控制比特承诺功能**</p>
<p>- 实现多等级选择（多组多目标选择）系统</p>
<p>- 支持中奖序号的智能分配</p>
<p>- **实现iAgent自动化承诺与揭示流程**，确保用户设置后可以自动执行承诺与揭示操作</p>
<p>- 支持多种去中心化应用场景（抽奖、彩票、分配、治理等）</p>
<p>- 提供可扩展的应用场景框架和配置系统</p>
<br/>
<p>#### 1.1.1 具体应用场景</p>
<p>系统支持多种去中心化决策投票应用场景，这些应用场景通过使用者创建不同的NFT类型来进行控制。以下是几个典型示例：</p>
<br/>
<p>**应用场景1：去中心化抽奖系统**</p>
<p>系统支持去中心化抽奖应用，实现以下功能：</p>
<p>- **NFT分发管理**：通过分发抽奖NFT来管理参与者，替代传统的用户注册功能</p>
<p>- **随机数提交**：每个NFT持有者提交整数作为随机数，使用比特承诺保护隐私</p>
<p>- **结果计算**：累加所有随机数之和，对参与者总数取余得到抽奖结果</p>
<p>- **结果验证**：整个计算过程透明可验证，确保公平性</p>
<p>- **防作弊机制**：通过密码学技术防止参与者作弊或操纵结果</p>
<p>- **多等级选择（多组多目标选择）**：支持设置不同等级和每个等级的数量，等价多个 n 选 k 编排</p>
<p>- **中奖序号管理**：每个NFT拥有与投票相关的中奖序号</p>
<br/>
<p>**应用场景2：去中心化彩票系统**</p>
<p>系统支持去中心化彩票应用，实现以下功能：</p>
<p>- **彩票NFT分发**：用户获得彩票NFT，替代传统注册流程</p>
<p>- **购买验证**：验证彩票NFT的有效性和唯一性</p>
<p>- **开奖机制**：基于参与者偏好值生成公平的开奖号码</p>
<p>- **中奖验证**：自动验证中奖彩票并分配奖金</p>
<p>- **奖金池管理**：透明管理彩票奖金池和分配规则</p>
<br/>
<p>**应用场景3：去中心化分配系统**</p>
<p>系统支持去中心化资源分配应用，实现以下功能：</p>
<p>- **资源分配NFT分发**：参与者获得资源分配NFT</p>
<p>- **偏好收集**：收集参与者对资源的偏好表达</p>
<p>- **分配算法**：实现多种分配算法（匈牙利算法、拍卖算法等）</p>
<p>- **结果验证**：验证分配结果的公平性和最优性</p>
<p>- **执行机制**：自动执行分配结果并更新资源状态</p>
<br/>
<p>**应用场景4：去中心化治理系统**</p>
<p>系统支持去中心化治理投票应用，实现以下功能：</p>
<p>- **治理NFT分发**：参与者获得治理投票NFT</p>
<p>- **提案管理**：支持治理提案的创建、修改和投票</p>
<p>- **投票机制**：实现多种投票规则（简单多数、加权投票等）</p>
<p>- **决策计算**：基于投票偏好计算最终决策结果</p>
<p>- **执行跟踪**：跟踪决策的执行情况和效果评估</p>
<p>- **治理历史**：维护完整的治理决策历史记录</p>
<br/>
<h3>1.2 设计原则</h3>
<p>- **隐私优先**：决策人偏好投票内容对第三方不可见</p>
<p>- **去中心化**：避免单点故障，提高系统可靠性，确保决策结果不依赖任何个人或部分人</p>
<p>- **偏好汇总**：系统汇总全体决策人的偏好，任何一个人的投票都会影响最终结果</p>
<p>- **透明计算**：计算过程透明，可被所有人验证</p>
<p>- **高性能**：利用WebAssembly技术实现高效计算</p>
<p>- **可验证性**：所有操作可公开验证</p>
<p>- **范围声明**：零知识证明不在本期范围；存储边界统一为“链上最小化 + IPFS（CID/版本为单一真实源）”。</p>
<p>- **可扩展性**：支持大规模决策人并发</p>
<p>- **代币权限控制**：基于代币持有量的权限管理</p>
<p>- **NFT类型驱动**：通过NFT类型控制不同的应用场景</p>
<p>- **NFT分发替代注册**：使用NFT分发替代传统用户注册功能</p>
<p>- **NFT状态控制**：通过NFT全局状态变量控制比特承诺功能</p>
<p>- **自动化执行**：通过iAgent实现承诺与揭示流程的自动化，减少人工干预</p>
<p>- **去中心化五原则落地**：架构与协议在分散与平等、全员一致性、抗合谋与抗操纵、偏好显示自由性、透明与可验证性上提供强保证。</p>
<br/>
<h3>1.3 决策类型统一术语与分类</h3>
<br/>
<p>- 概念定位：上述类型均抽象为“系统内置NFT类型”，与应用场景解耦；不同场景仅是对这些NFT类型的编排与配置。</p>
<p>- 按结果基数：单目标决策 / 多目标决策</p>
<p>- 按资源属性：竞用性资源决策 / 非竞用性资源决策</p>
<p>- 通过NFT类型抽象承载以上类别，支持未来扩展。</p>
<br/>
<p>> 关系补充：唯一中奖= n 选 1（多目标特例）；多等级选择=多个 n 选 k 的组合（定义为"多组多目标选择"）；单个 n 选 k 对应 1 组偏好值，多个 n 选 k 对应多组偏好值。不同应用场景通过“选择匹配的NFT类型”来复用这些能力。</p>
<br/>
<h3>1.3 技术选型</h3>
<p>- **核心语言**：Rust + WebAssembly</p>
<p>- **区块链平台**：Injective Protocol（高性能、低费用）</p>
<p>- **智能合约**：Rust (CosmWasm)</p>
<p>- **密码学库**：RustCrypto、sha2、rand</p>
<p>- **存储方案**：IPFS去中心化存储 + 链上哈希验证</p>
<p>- **前端框架**：React + TypeScript</p>
<p>- **代币标准**：CW20 (CosmWasm代币标准)</p>
<p>- **NFT标准**：CW721 (CosmWasm NFT标准)</p>
<p>- **状态管理**：NFT全局状态变量 + 智能合约状态管理</p>
<br/>
<h2>2. 系统架构</h2>
<br/>
<h3>2.1 整体架构图</h3>
<pre><code>
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   客户端SDK     │    │ WebAssembly服务器    │    │   区块链网络    │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ 偏好投票    │ │◄──►│ │ 决策投票    │ │◄──►│ │ 智能合约    │ │
│ │ 验证工具    │ │    │ │ 生命周期    │ │    │ │ 承诺存储    │ │
│ │ 连接管理    │ │    │ │ 区块链接口  │ │    │ │ 结果记录    │ │
│ │ NFT类型管理 │ │    │ │ 代币验证    │ │    │ │ 代币合约    │ │
│ │ NFT分发管理 │ │    │ │ NFT类型管理 │ │    │ │ NFT合约     │ │
│ │ NFT状态管理 │ │    │ │ NFT状态管理 │ │    │ │ 状态管理合约 │ │
│ │ 抽奖等级    │ │    │ │ iAgent管理  │ │    │ │ 自动化合约  │ │
│ │ iAgent配置  │ │    │ │ 比特承诺    │ │    │ │ 比特承诺合约 │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   密码学核心    │    │   存储策略      │    │   去中心化存储  │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ 比特承诺    │ │    │ │ 链上优化    │ │    │ │ IPFS节点    │ │
│ │ 随机数生成  │ │    │ │ IPFS适配    │ │    │ │ 数据分片    │ │
│ │ 哈希函数    │ │    │ │ 完整性验证  │ │    │ │ 冗余备份    │ │
│ │ 中奖序号    │ │    │ │ NFT元数据   │ │    │ │ 元数据存储  │ │
│ │ NFT状态控制 │ │    │ │ NFT状态     │ │    │ │ 状态存储    │ │
│ │ iAgent自动化 │ │    │ │ 自动化配置  │ │    │ │ 自动化状态  │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
</code></pre>
<br/>
<h3>2.2 分层架构</h3>
<p>1. **表示层**：客户端SDK、Web界面</p>
<p>2. **业务逻辑层**：WebAssembly服务器、决策投票管理、代币验证、NFT类型管理、NFT状态管理</p>
<p>3. **数据访问层**：区块链接口、存储适配器、代币合约接口、NFT状态接口</p>
<p>4. **基础设施层**：密码学核心、网络通信、代币标准、NFT状态标准</p>
<br/>
<h3>2.2.1 源码目录结构（src）</h3>
<pre><code>
src/
  frontend/   # 前端：Web UI、SDK集成、钱包交互
  home/       # 主页与落地页：营销/入口与文档导航
  server/     # 服务器端：WASM服务、API网关、会话与状态编排
  contracts/  # 智能合约接口与绑定：CW20/CW721、投票/状态管理合约适配
  ipfs/       # 第三方IPFS适配：网关、存储适配器、完整性校验
  wasm/       # WebAssembly：高性能计算模块与生命周期管理
  sdk/        # 客户端/服务端SDK：TS/Rust SDK、签名与验证工具
</code></pre>
<br/>
<p>设计 rationale：</p>
<p>- 与架构分层一一对应，便于职责清晰与团队协作。</p>
<p>- `server` 聚合对区块链与IPFS的编排，`contracts` 专注合约接口与消息/类型绑定。</p>
<p>- `wasm` 独立，确保计算密集型逻辑可复用、可测试与可替换。</p>
<p>- `sdk` 面向前后端统一的开发者体验，降低集成成本。</p>
<p>- `home` 与 `frontend` 分离，允许主页与产品前台独立上线、灰度与缓存策略。</p>
<br/>
<h3>2.3 统一NFT决策状态机（架构）</h3>
<p>状态：Draft → CommitOpen → CommitClosed → RevealOpen → Revealed → Tallied → Executed → Archived</p>
<br/>
<p>- 与时间参数、权限与NFT类型规则绑定；</p>
<p>- 各模块（承诺、揭示、计票、执行）通过状态机编排；</p>
<p>- 事件与审计在每次迁移时产生。</p>
<br/>
<h2>3. 模块设计</h2>
<br/>
<h3>3.1 NFT类型管理模块</h3>
<p>#### 3.1.1 NFT类型定义和控制</p>
<pre><code>
pub struct NFTTypeManager {
    pub registered_types: HashMap&lt;String, NFTTypeDefinition&gt;,
    pub type_validator: NFTTypeValidator,
    pub type_registry: NFTTypeRegistry,
}

#[derive(Debug, Clone)]
pub struct NFTTypeDefinition {
    pub nft_type: String,                    // NFT类型标识
    pub nft_standard: String,                // NFT标准（如CW721）
    pub application_category: String,         // 应用场景分类
    pub metadata_schema: MetadataSchema,     // 元数据模式
    pub voting_rules: VotingRules,           // 投票规则
    pub lifecycle_hooks: LifecycleHooks,     // 生命周期钩子
    pub global_state_schema: StateSchema,    // 全局状态模式
}

#[derive(Debug, Clone)]
pub struct StateSchema {
    pub state_variables: Vec&lt;StateVariable&gt;, // 状态变量定义
    pub state_transitions: Vec&lt;StateTransition&gt;, // 状态转换规则
    pub state_constraints: Vec&lt;StateConstraint&gt;, // 状态约束条件
}

impl NFTTypeManager {
    pub async fn create_nft_type(
        &amp;mut self,
        definition: NFTTypeDefinition
    ) -&gt; Result&lt;String, Error&gt; {
        // 验证NFT类型定义
        self.type_validator.validate_nft_type(&amp;definition)?;
        
        // 注册NFT类型
        let type_id = self.generate_type_id(&amp;definition);
        self.registered_types.insert(type_id.clone(), definition);
        
        // 初始化NFT类型状态
        self.initialize_nft_type_state(&amp;type_id).await?;
        
        Ok(type_id)
    }
    
    pub async fn get_nft_type_config(
        &amp;self,
        nft_type: &amp;str
    ) -&gt; Option&lt;&amp;NFTTypeDefinition&gt; {
        self.registered_types.get(nft_type)
    }
    
    async fn initialize_nft_type_state(&amp;self, type_id: &amp;str) -&gt; Result&lt;(), Error&gt; {
        // 初始化NFT类型的全局状态变量
        let state_manager = NFTStateManager::new();
        state_manager.initialize_type_state(type_id).await?;
        Ok(())
    }
}
</code></pre>
<br/>
<h3>3.1.x NFT决策接口（抽象）</h3>
<pre><code>
1) 提案/会话创建（引用NFT类型全局参数配置，设置时间参数、范围与阈值）
2) 偏好投票提交（承诺）
3) 隐私保护（比特承诺：commit/opening/salt）
4) 揭示与计票（单/多目标、竞/非竞）
5) 决策执行（按NFT类型：抽奖/彩票/分配/治理）
</code></pre>
<br/>
<p>#### 3.1.2 应用场景控制</p>
<pre><code>
pub struct ApplicationScenarioController {
    pub nft_type_manager: NFTTypeManager,
    pub scenario_registry: HashMap&lt;String, ApplicationScenario&gt;,
}

#[derive(Debug, Clone)]
pub struct ApplicationScenario {
    pub scenario_id: String,
    pub nft_type: String,
    pub scenario_config: ScenarioConfig,
    pub is_active: bool,
    pub created_at: u64,
}

impl ApplicationScenarioController {
    pub async fn create_scenario(
        &amp;mut self,
        nft_type: String,
        config: ScenarioConfig
    ) -&gt; Result&lt;String, Error&gt; {
        // 验证NFT类型是否存在
        if self.nft_type_manager.get_nft_type_config(&amp;nft_type).is_none() {
            return Err("NFT type not found".into());
        }
        
        let scenario_id = self.generate_scenario_id(&amp;nft_type);
        let scenario = ApplicationScenario {
            scenario_id: scenario_id.clone(),
            nft_type,
            scenario_config: config,
            is_active: true,
            created_at: self.get_current_timestamp(),
        };
        
        self.scenario_registry.insert(scenario_id.clone(), scenario);
        Ok(scenario_id)
    }
    
    pub async fn get_scenario_by_nft_type(
        &amp;self,
        nft_type: &amp;str
    ) -&gt; Option&lt;&amp;ApplicationScenario&gt; {
        self.scenario_registry.values()
            .find(|s| s.nft_type == nft_type &amp;&amp; s.is_active)
    }
}
</code></pre>
<br/>
<h3>3.2 NFT分发管理模块</h3>
<p>#### 3.2.1 NFT分发替代用户注册</p>
<pre><code>
pub struct NFTDistributionManager {
    pub distribution_strategies: HashMap&lt;String, DistributionStrategy&gt;,
    pub nft_factory: NFTFactory,
    pub eligibility_checker: EligibilityChecker,
}

#[derive(Debug, Clone)]
pub enum DistributionStrategy {
    Direct,         // 直接分发
    Batch,          // 批量分发
    Conditional,    // 条件分发
    Lottery,        // 抽奖分发
}

impl NFTDistributionManager {
    pub async fn distribute_nft(
        &amp;mut self,
        user_address: String,
        nft_type: String,
        strategy: DistributionStrategy
    ) -&gt; Result&lt;String, Error&gt; {
        // 检查用户资格
        if !self.eligibility_checker.check_eligibility(&amp;user_address, &amp;nft_type).await? {
            return Err("User not eligible for this NFT type".into());
        }
        
        // 根据策略分发NFT
        let nft_id = match strategy {
            DistributionStrategy::Direct =&gt; {
                self.distribute_direct(&amp;user_address, &amp;nft_type).await?
            }
            DistributionStrategy::Batch =&gt; {
                self.add_to_batch_distribution(&amp;user_address, &amp;nft_type).await?
            }
            DistributionStrategy::Conditional =&gt; {
                self.distribute_conditional(&amp;user_address, &amp;nft_type).await?
            }
            DistributionStrategy::Lottery =&gt; {
                self.distribute_lottery(&amp;user_address, &amp;nft_type).await?
            }
        };
        
        Ok(nft_id)
    }
    
    async fn distribute_direct(
        &amp;self,
        user_address: &amp;str,
        nft_type: &amp;str
    ) -&gt; Result&lt;String, Error&gt; {
        // 直接创建并分发NFT
        let nft = self.nft_factory.create_nft(user_address, nft_type).await?;
        Ok(nft.nft_id)
    }
    
    async fn add_to_batch_distribution(
        &amp;mut self,
        user_address: &amp;str,
        nft_type: &amp;str
    ) -&gt; Result&lt;String, Error&gt; {
        // 添加到批量分发队列
        let batch_id = self.get_or_create_batch(nft_type).await?;
        self.add_user_to_batch(batch_id, user_address).await?;
        Ok(batch_id)
    }
}
</code></pre>
<br/>
<p>#### 3.2.2 NFT资格验证</p>
<pre><code>
pub struct EligibilityChecker {
    pub token_verifier: TokenVerifier,
    pub nft_ownership_checker: NFTOwnershipChecker,
    pub eligibility_rules: HashMap&lt;String, Vec&lt;EligibilityRule&gt;&gt;,
}

#[derive(Debug, Clone)]
pub struct EligibilityRule {
    pub rule_type: RuleType,
    pub parameters: HashMap&lt;String, String&gt;,
    pub is_required: bool,
}

#[derive(Debug, Clone)]
pub enum RuleType {
    TokenHolding,       // 代币持有量要求
    NFTOwnership,       // NFT所有权要求
    TimeBased,          // 时间要求
    Geographic,          // 地理要求
    Custom,             // 自定义要求
}

impl EligibilityChecker {
    pub async fn check_eligibility(
        &amp;self,
        user_address: &amp;str,
        nft_type: &amp;str
    ) -&gt; Result&lt;bool, Error&gt; {
        let rules = self.eligibility_rules.get(nft_type)
            .ok_or("No eligibility rules found for NFT type")?;
        
        for rule in rules {
            let is_eligible = self.check_rule(user_address, rule).await?;
            if rule.is_required &amp;&amp; !is_eligible {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    async fn check_rule(
        &amp;self,
        user_address: &amp;str,
        rule: &amp;EligibilityRule
    ) -&gt; Result&lt;bool, Error&gt; {
        match rule.rule_type {
            RuleType::TokenHolding =&gt; {
                self.check_token_holding_rule(user_address, rule).await
            }
            RuleType::NFTOwnership =&gt; {
                self.check_nft_ownership_rule(user_address, rule).await
            }
            RuleType::TimeBased =&gt; {
                self.check_time_based_rule(user_address, rule).await
            }
            _ =&gt; Ok(true), // 其他规则类型
        }
    }
}
</code></pre>
<br/>
<h3>3.3 NFT全局状态管理模块</h3>
<p>#### 3.3.1 全局状态变量管理</p>
<p>##### 3.3.1.a 状态Schema与变量白名单（标准化）</p>
<p>以下为跨NFT类型的推荐全局状态变量集合（按需裁剪），并定义类型与语义：</p>
<p>- commitment_enabled: Boolean（是否允许承诺）</p>
<p>- reveal_enabled: Boolean（是否允许揭示）</p>
<p>- calculation_enabled: Boolean（是否允许计算）</p>
<p>- max_participants: Number（最大参与者数）</p>
<p>- total_participants: Number（已注册/有效参与者数）</p>
<p>- total_commitments: Number（承诺计数）</p>
<p>- total_reveals: Number（揭示计数）</p>
<p>- min_revealed_for_calculation: Number（允许计算的最小揭示数）</p>
<p>- winners_calculated: Boolean（是否已完成计算）</p>
<p>- calculation_timestamp: Number（最近一次计算时间戳）</p>
<p>- config_cid: String（当前有效配置的CID/版本）</p>
<p>- agent_policy: Object（iAgent策略摘要）</p>
<br/>
<p>状态迁移规则：仅允许 Draft→CommitOpen→CommitClosed→RevealOpen→Revealed→Tallied→Executed→Archived 的有序迁移；变量变更需与当前状态兼容。</p>
<pre><code>
pub struct NFTStateManager {
    pub global_states: HashMap&lt;String, GlobalState&gt;,
    pub state_transitions: HashMap&lt;String, Vec&lt;StateTransition&gt;&gt;,
    pub state_validator: StateValidator,
}

#[derive(Debug, Clone)]
pub struct GlobalState {
    pub nft_type: String,
    pub state_variables: HashMap&lt;String, StateValue&gt;,
    pub current_state: String,
    pub last_updated: u64,
    pub version: u32,
}

#[derive(Debug, Clone)]
pub enum StateValue {
    String(String),
    Number(i64),
    Boolean(bool),
    Array(Vec&lt;StateValue&gt;),
    Object(HashMap&lt;String, StateValue&gt;),
}

impl NFTStateManager {
    pub async fn update_global_state(
        &amp;mut self,
        nft_type: &amp;str,
        variable_name: &amp;str,
        new_value: StateValue
    ) -&gt; Result&lt;(), Error&gt; {
        let global_state = self.global_states.get_mut(nft_type)
            .ok_or("Global state not found for NFT type")?;
        
        // 验证状态转换是否有效
        if let Some(transitions) = self.state_transitions.get(nft_type) {
            let is_valid = self.validate_state_transition(
                nft_type,
                variable_name,
                &amp;global_state.state_variables.get(variable_name),
                &amp;new_value,
                transitions
            ).await?;
            
            if !is_valid {
                return Err("Invalid state transition".into());
            }
        }
        
        // 更新状态变量
        global_state.state_variables.insert(variable_name.to_string(), new_value);
        global_state.last_updated = self.get_current_timestamp();
        global_state.version += 1;
        
        Ok(())
    }
    
    pub async fn get_global_state(
        &amp;self,
        nft_type: &amp;str
    ) -&gt; Option&lt;&amp;GlobalState&gt; {
        self.global_states.get(nft_type)
    }
    
    pub async fn get_state_variable(
        &amp;self,
        nft_type: &amp;str,
        variable_name: &amp;str
    ) -&gt; Option&lt;&amp;StateValue&gt; {
        self.global_states.get(nft_type)
            .and_then(|state| state.state_variables.get(variable_name))
    }
}
</code></pre>
<br/>
<p>#### 3.3.2 比特承诺状态控制</p>
<pre><code>
pub struct BitCommitmentStateController {
    pub nft_state_manager: NFTStateManager,
    pub commitment_manager: BitCommitmentManager,
    pub state_hooks: HashMap&lt;String, StateHook&gt;,
}

#[derive(Debug, Clone)]
pub struct StateHook {
    pub hook_type: HookType,
    pub trigger_condition: TriggerCondition,
    pub action: HookAction,
}

#[derive(Debug, Clone)]
pub enum HookType {
    PreCommitment,      // 承诺前钩子
    PostCommitment,     // 承诺后钩子
    PreReveal,          // 揭示前钩子
    PostReveal,         // 揭示后钩子
    StateChange,        // 状态变更钩子
}

impl BitCommitmentStateController {
    pub async fn execute_commitment_with_state_check(
        &amp;mut self,
        nft_type: &amp;str,
        message: Vec&lt;u8&gt;,
        user_address: &amp;str
    ) -&gt; Result&lt;String, Error&gt; {
        // 检查NFT状态是否允许承诺
        let can_commit = self.check_commitment_state(nft_type, user_address).await?;
        if !can_commit {
            return Err("NFT state does not allow commitment".into());
        }
        
        // 执行承诺
        let commitment_id = self.commitment_manager.commit(message).await?;
        
        // 更新NFT状态
        self.update_commitment_state(nft_type, user_address, &amp;commitment_id).await?;
        
        // 执行承诺后钩子
        self.execute_hooks(nft_type, HookType::PostCommitment, &amp;commitment_id).await?;
        
        Ok(commitment_id)
    }
    
    async fn check_commitment_state(
        &amp;self,
        nft_type: &amp;str,
        user_address: &amp;str
    ) -&gt; Result&lt;bool, Error&gt; {
        let global_state = self.nft_state_manager.get_global_state(nft_type)
            .ok_or("Global state not found")?;
        
        // 检查承诺状态变量
        if let Some(commitment_state) = global_state.state_variables.get("commitment_enabled") {
            if let StateValue::Boolean(enabled) = commitment_state {
                return Ok(*enabled);
            }
        }
        
        // 检查用户特定状态
        if let Some(user_state) = global_state.state_variables.get(&amp;format!("user_{}_state", user_address)) {
            if let StateValue::String(state) = user_state {
                return Ok(state == "active");
            }
        }
        
        Ok(true) // 默认允许
    }
    
    async fn update_commitment_state(
        &amp;mut self,
        nft_type: &amp;str,
        user_address: &amp;str,
        commitment_id: &amp;str
    ) -&gt; Result&lt;(), Error&gt; {
        // 更新用户承诺状态
        let user_state_key = format!("user_{}_commitment", user_address);
        let user_state_value = StateValue::String(commitment_id.to_string());
        
        self.nft_state_manager.update_global_state(
            nft_type,
            &amp;user_state_key,
            user_state_value
        ).await?;
        
        // 更新全局承诺计数
        let count_key = "total_commitments";
        let current_count = self.nft_state_manager.get_state_variable(nft_type, count_key)
            .and_then(|v| {
                if let StateValue::Number(n) = v { Some(*n) } else { None }
            })
            .unwrap_or(0);
        
        self.nft_state_manager.update_global_state(
            nft_type,
            count_key,
            StateValue::Number(current_count + 1)
        ).await?;
        
        Ok(())
    }
}
</code></pre>
<br/>
<h3>3.4 代币验证模块</h3>
<br/>
<h3>3.5 iAgent自动化模块</h3>
<p>#### 3.5.1 自动化承诺管理</p>
<pre><code>
pub struct IAgentCommitmentManager {
    pub config: IAgentConfig,
    pub automation_enabled: bool,
    pub commitment_strategy: CommitmentStrategy,
    pub reveal_conditions: Vec&lt;RevealCondition&gt;,
}

#[derive(Debug, Clone)]
pub enum CommitmentStrategy {
    Immediate,      // 立即承诺
    Scheduled,      // 定时承诺
    Conditional,    // 条件触发承诺
    Batch,          // 批量承诺
}

impl IAgentCommitmentManager {
    pub async fn setup_automated_commitment(
        &amp;mut self,
        message: Vec&lt;u8&gt;,
        strategy: &amp;CommitmentStrategy,
        conditions: &amp;[RevealCondition]
    ) -&gt; Result&lt;String, Error&gt; {
        // 根据策略自动设置承诺和揭示流程
        match strategy {
            CommitmentStrategy::Immediate =&gt; {
                self.execute_immediate_commitment(message).await
            }
            CommitmentStrategy::Scheduled =&gt; {
                self.schedule_commitment(message, conditions).await
            }
            CommitmentStrategy::Conditional =&gt; {
                self.setup_conditional_commitment(message, conditions).await
            }
            CommitmentStrategy::Batch =&gt; {
                self.add_to_batch_queue(message).await
            }
        }
    }
    
    pub async fn execute_automated_reveal(&amp;mut self, commitment_id: &amp;str) -&gt; Result&lt;(), Error&gt; {
        // 自动执行揭示操作
        if self.should_auto_reveal(commitment_id).await? {
            self.reveal_commitment(commitment_id).await?;
        }
        Ok(())
    }
}
</code></pre>
<br/>
<p>#### 3.5.2 自动化投票管理</p>
<pre><code>
pub struct IAgentVotingManager {
    pub commitment_manager: IAgentCommitmentManager,
    pub voting_automation: VotingAutomation,
    pub auto_reveal_service: AutoRevealService,
}

impl IAgentVotingManager {
    pub async fn setup_automated_voting(
        &amp;mut self,
        vote_config: AutomatedVoteConfig
    ) -&gt; Result&lt;String, Error&gt; {
        // 设置自动化投票流程
        let vote_id = self.generate_vote_id(&amp;vote_config);
        
        // 配置自动承诺
        self.commitment_manager.setup_automated_commitment(
            vote_config.message.clone(),
            &amp;vote_config.commitment_strategy,
            &amp;vote_config.reveal_conditions
        ).await?;
        
        // 配置自动揭示触发器
        self.setup_reveal_triggers(&amp;vote_id, &amp;vote_config.reveal_triggers).await?;
        
        Ok(vote_id)
    }
    
    pub async fn process_automated_voting_cycle(&amp;mut self, vote_id: &amp;str) -&gt; Result&lt;(), Error&gt; {
        // 自动处理投票生命周期
        let vote_status = self.get_vote_status(vote_id).await?;
        
        match vote_status {
            DecisionVoteStatus::Active =&gt; {
                self.execute_automated_commitment(vote_id).await?;
            }
            DecisionVoteStatus::Closed =&gt; {
                if self.should_auto_reveal(vote_id).await? {
                    self.execute_automated_reveal(vote_id).await?;
                }
            }
            _ =&gt; {}
        }
        
        Ok(())
    }
}
</code></pre>
<br/>
<p>#### 3.5.3 智能合约自动化支持</p>
<pre><code>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ExecuteMsg {
    // 现有消息类型...
    SetupAutomatedVoting {
        decision_vote_id: String,
        automation_config: AutomationConfig,
    },
    ExecuteAutomatedCommitment {
        decision_vote_id: String,
        commitment_batch: Vec&lt;String&gt;,
    },
    ExecuteAutomatedReveal {
        decision_vote_id: String,
        reveal_batch: Vec&lt;RevealData&gt;,
    },
}

pub fn execute_setup_automated_voting(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    decision_vote_id: String,
    automation_config: AutomationConfig,
) -&gt; Result&lt;Response, StdError&gt; {
    // 设置自动化投票配置
    let automation_state = AutomationState {
        is_automated: true,
        config: Some(automation_config.clone()),
        last_automation_run: Some(env.block.time.seconds()),
        automation_status: "active".to_string(),
        batch_queue: Vec::new(),
        reveal_queue: Vec::new(),
    };
    
    save_automation_state(deps.storage, &amp;decision_vote_id, &amp;automation_state)?;
    
    Ok(Response::new()
        .add_attribute("action", "setup_automated_voting")
        .add_attribute("decision_vote_id", decision_vote_id)
        .add_attribute("agent_id", automation_config.agent_id))
}
</code></pre>
<p>#### 3.1.1 代币持有验证</p>
<pre><code>
pub struct TokenVerifier {
    contract_address: String,
    min_token_amount: Uint128,
}

impl TokenVerifier {
    pub async fn verify_token_holding(&amp;self, user_address: &amp;str) -&gt; Result&lt;bool, Error&gt; {
        // 查询用户代币余额
        let balance = self.query_token_balance(user_address).await?;
        
        // 验证是否满足最小持有量要求
        Ok(balance &gt;= self.min_token_amount)
    }
    
    pub async fn query_token_balance(&amp;self, user_address: &amp;str) -&gt; Result&lt;Uint128, Error&gt; {
        // 调用代币合约查询余额
        let query_msg = QueryMsg::Balance {
            address: user_address.to_string(),
        };
        
        let response = self.client
            .query_contract(&amp;self.contract_address, &amp;query_msg)
            .await?;
            
        Ok(response.balance)
    }
}
</code></pre>
<br/>
<p>#### 3.1.2 代币权限控制</p>
<p>- 只有持有足够$LUCKEE代币的用户才能创建/更新NFT类型全局参数配置</p>
<p>- 代币持有量决定用户权限等级</p>
<p>- 支持代币质押和锁定机制</p>
<br/>
<h3>3.6 NFT管理模块</h3>
<p>#### 3.6.1 NFT创建和管理</p>
<pre><code>
pub struct NFTManager {
    contract_address: String,
    nft_standard: NFTStandard,
}

#[derive(Debug, Clone)]
pub enum NFTStandard {
    CW721,
    CW1155,
}

#[derive(Debug, Clone)]
pub struct NFTMetadata {
    pub name: String,
    pub description: String,
    pub image: String,
    pub attributes: Vec&lt;NFTAttribute&gt;,
    pub voting_project_id: String,
    pub lottery_tier: Option&lt;LotteryTier&gt;,
    pub winning_number: Option&lt;u64&gt;,
}

#[derive(Debug, Clone)]
pub struct NFTAttribute {
    pub trait_type: String,
    pub value: String,
}

#[derive(Debug, Clone)]
pub struct LotteryTier {
    pub tier_id: u32,
    pub tier_name: String,
    pub prize_description: String,
    pub winner_count: u32,
}

impl NFTManager {
    pub async fn create_voting_nft(&amp;self, metadata: NFTMetadata) -&gt; Result&lt;String, Error&gt; {
        // 创建NFT
        let mint_msg = MintMsg {
            token_id: self.generate_token_id(&amp;metadata.voting_project_id),
            owner: metadata.voting_project_id.clone(),
            token_uri: self.store_metadata(&amp;metadata).await?,
            extension: None,
        };
        
        let response = self.client
            .execute_contract(&amp;self.contract_address, &amp;mint_msg)
            .await?;
            
        Ok(response.tx_hash)
    }
    
    pub async fn verify_nft_ownership(&amp;self, user_address: &amp;str, token_id: &amp;str) -&gt; Result&lt;bool, Error&gt; {
        // 验证用户是否拥有指定NFT
        let owner = self.query_nft_owner(token_id).await?;
        Ok(owner == user_address)
    }
    
    pub async fn assign_winning_number(&amp;self, token_id: &amp;str, winning_number: u64) -&gt; Result&lt;(), Error&gt; {
        // 为NFT分配中奖序号
        let update_msg = UpdateMetadataMsg {
            token_id: token_id.to_string(),
            token_uri: self.update_winning_number_metadata(token_id, winning_number).await?,
        };
        
        self.client
            .execute_contract(&amp;self.contract_address, &amp;update_msg)
            .await?;
            
        Ok(())
    }
}
</code></pre>
<br/>
<p>#### 3.6.2 投票资格验证</p>
<p>- 只有拥有对应NFT的账户才具有投票资格</p>
<p>- NFT包含NFT类型标识与投票相关属性（通过配置CID/版本引用NFT类型全局参数）</p>
<p>- 支持NFT的转移和交易</p>
<br/>
<h3>3.7 抽奖等级系统（基于抽奖/彩票的多目标选择模式）</h3>
<h3>3.13 资源决策模块（竞用性/非竞用性）</h3>
<p>#### 3.13.1 竞用性资源决策（匹配/分配）</p>
<p>- 输入：参与者集合 U、资源集合 R，每个 r∈R 具容量 cap(r)≥0；偏好/效用矩阵 W∈R^{|U|×|R|}；约束与资格过滤函数 Q。</p>
<p>- 目标：最大化 Σ_{u,r} x_{u,r}·W_{u,r}，s.t. 每个 u 分配至至多一个 r；Σ_u x_{u,r}≤cap(r)；Q(u,r)=true；x_{u,r}∈{0,1}。</p>
<p>- 算法：匈牙利算法（方阵扩充）或最大权匹配（一般二分图），容量>1 通过多副本或流量建模；不可行时输出最大可行匹配。</p>
<p>- 证明产物：匹配边集合、容量与资格约束满足证明、最优性或近似度量；链上摘要+IPFS明细。</p>
<br/>
<p>#### 3.13.2 非竞用性资源决策（阈值/预算选择）</p>
<p>- 输入：公共品集合 G，每个 g 设通过阈值 θ_g 与成本 c_g（可选）；参与者对 g 的支持强度 s_{u,g} 与权重 w_u（可选，代币/NFT映射）。</p>
<p>- 聚合：S_g = Σ_u w_u·s_{u,g}。</p>
<p>- 规则：</p>
<p>  - 阈值型：选择 {g | S_g ≥ θ_g}，可并行通过多个 g。</p>
<p>  - 预算型（可选）：在 Σ_g z_g·c_g ≤ B 下最大化 Σ_g z_g·f(S_g)（f 为单调函数），z_g∈{0,1}（背包/子集选择）。</p>
<p>- 证明产物：各 g 的 S_g、阈值/预算可行性与选择最优性（或近似因子）；链上摘要+IPFS明细。</p>
<p>#### 3.7.1 等级配置管理</p>
<pre><code>
#[derive(Debug, Clone)]
pub struct LotteryTierConfig {
    pub tier_id: u32,
    pub tier_name: String,
    pub prize_description: String,
    pub winner_count: u32,
    pub min_participants: u32,
    pub probability: f64,
}

#[derive(Debug, Clone)]
pub struct LotteryProject {
    pub project_id: String,
    pub title: String,
    pub description: String,
    pub tiers: Vec&lt;LotteryTierConfig&gt;,
    pub total_participants: u32,
    pub status: LotteryStatus,
    pub creator: String,
}

#[derive(Debug, Clone)]
pub enum LotteryStatus {
    Created,
    Active,
    Closed,
    WinnersSelected,
}

pub struct LotteryManager {
    pub projects: HashMap&lt;String, LotteryProject&gt;,
}

impl LotteryManager {
    pub fn create_lottery_project(&amp;mut self, config: LotteryProjectConfig) -&gt; Result&lt;String, Error&gt; {
        let project_id = self.generate_project_id(&amp;config);
        
        let project = LotteryProject {
            project_id: project_id.clone(),
            title: config.title,
            description: config.description,
            tiers: config.tiers,
            total_participants: 0,
            status: LotteryStatus::Created,
            creator: config.creator,
        };
        
        self.projects.insert(project_id.clone(), project);
        Ok(project_id)
    }
    
    pub fn set_lottery_tiers(&amp;mut self, project_id: &amp;str, tiers: Vec&lt;LotteryTierConfig&gt;) -&gt; Result&lt;(), Error&gt; {
        if let Some(project) = self.projects.get_mut(project_id) {
            project.tiers = tiers;
            Ok(())
        } else {
            Err(Error::ProjectNotFound)
        }
    }
    
    pub fn calculate_winners(&amp;mut self, project_id: &amp;str, random_numbers: Vec&lt;i64&gt;) -&gt; Result&lt;Vec&lt;Winner&gt;, Error&gt; {
        let project = self.projects.get_mut(project_id)
            .ok_or(Error::ProjectNotFound)?;
            
        if project.status != LotteryStatus::Closed {
            return Err(Error::InvalidStatus);
        }
        
        let total_sum: i64 = random_numbers.iter().sum();
        let participant_count = random_numbers.len() as u64;
        
        let mut winners = Vec::new();
        let mut used_indices = HashSet::new();
        
        // 为每个等级分配中奖者
        for tier in &amp;project.tiers {
            let tier_winners = self.select_tier_winners(
                &amp;random_numbers,
                &amp;mut used_indices,
                tier.winner_count,
                total_sum,
                participant_count
            )?;
            
            for winner in tier_winners {
                winners.push(winner);
            }
        }
        
        project.status = LotteryStatus::WinnersSelected;
        Ok(winners)
    }
    
    fn select_tier_winners(
        &amp;self,
        random_numbers: &amp;[i64],
        used_indices: &amp;mut HashSet&lt;usize&gt;,
        winner_count: u32,
        total_sum: i64,
        participant_count: u64
    ) -&gt; Result&lt;Vec&lt;Winner&gt;, Error&gt; {
        let mut winners = Vec::new();
        let mut attempts = 0;
        let max_attempts = participant_count * 2; // 防止无限循环
        
        while winners.len() &lt; winner_count as usize &amp;&amp; attempts &lt; max_attempts {
            attempts += 1;
            
            // 使用总和对参与者数量取余，然后加上随机偏移
            let base_index = (total_sum % participant_count as i64) as usize;
            let offset = (attempts as u64 % participant_count) as usize;
            let candidate_index = (base_index + offset) % random_numbers.len();
            
            if !used_indices.contains(&amp;candidate_index) {
                used_indices.insert(candidate_index);
                winners.push(Winner {
                    participant_index: candidate_index,
                    random_number: random_numbers[candidate_index],
                    tier_id: 0, // 将在调用方设置
                });
            }
        }
        
        Ok(winners)
    }
}

#[derive(Debug, Clone)]
pub struct Winner {
    pub participant_index: usize,
    pub random_number: i64,
    pub tier_id: u32,
}
</code></pre>
<br/>
<p>#### 3.7.2 中奖序号分配算法（与 n 选 k 的关系）</p>
<p>> 等价关系：</p>
<p>> - 唯一中奖 ≈ n 选 1；</p>
<p>> - 多等级 = 多个 n 选 k 并行/串行编排；</p>
<p>> - 不同等级可独立配置 k、规则与偏好组。</p>
<pre><code>
pub struct WinningNumberAllocator {
    pub allocation_strategy: AllocationStrategy,
}

#[derive(Debug, Clone)]
pub enum AllocationStrategy {
    Sequential,      // 顺序分配
    Random,          // 随机分配
    Weighted,        // 基于权重的分配
    TierBased,       // 基于等级的分配
}

impl WinningNumberAllocator {
    pub fn allocate_winning_numbers(
        &amp;self,
        participants: &amp;[Participant],
        tiers: &amp;[LotteryTierConfig],
        random_seed: u64
    ) -&gt; Result&lt;Vec&lt;WinningNumber&gt;, Error&gt; {
        match self.allocation_strategy {
            AllocationStrategy::Sequential =&gt; {
                self.allocate_sequential(participants, tiers)
            }
            AllocationStrategy::Random =&gt; {
                self.allocate_random(participants, tiers, random_seed)
            }
            AllocationStrategy::Weighted =&gt; {
                self.allocate_weighted(participants, tiers)
            }
            AllocationStrategy::TierBased =&gt; {
                self.allocate_tier_based(participants, tiers)
            }
        }
    }
    
    fn allocate_tier_based(
        &amp;self,
        participants: &amp;[Participant],
        tiers: &amp;[LotteryTierConfig]
    ) -&gt; Result&lt;Vec&lt;WinningNumber&gt;, Error&gt; {
        let mut winning_numbers = Vec::new();
        let mut available_participants: Vec&lt;usize&gt; = (0..participants.len()).collect();
        
        for tier in tiers {
            let tier_winners = self.select_tier_winners(
                &amp;available_participants,
                tier.winner_count,
                participants
            )?;
            
            for (i, winner_index) in tier_winners.iter().enumerate() {
                winning_numbers.push(WinningNumber {
                    participant_index: *winner_index,
                    winning_number: self.generate_winning_number(tier.tier_id, i as u32),
                    tier_id: tier.tier_id,
                });
                
                // 从可用参与者中移除已中奖的
                available_participants.retain(|&amp;x| x != *winner_index);
            }
        }
        
        Ok(winning_numbers)
    }
    
    fn generate_winning_number(&amp;self, tier_id: u32, position: u32) -&gt; u64 {
        // 生成中奖序号：tier_id * 10000 + position * 100 + random_offset
        let base = tier_id as u64 * 10000 + position as u64 * 100;
        let random_offset = rand::random::&lt;u64&gt;() % 100;
        base + random_offset
    }
}

#[derive(Debug, Clone)]
pub struct WinningNumber {
    pub participant_index: usize,
    pub winning_number: u64,
    pub tier_id: u32,
}

#[derive(Debug, Clone)]
pub struct Participant {
    pub address: String,
    pub random_number: i64,
    pub nft_token_id: String,
}
</code></pre>
<br/>
<h3>3.8 密码学核心模块</h3>
<p>#### 3.8.1 比特承诺协议</p>
<pre><code>
pub struct BitCommitment {
    pub commitment: Vec&lt;u8&gt;,
    pub opening: Vec&lt;u8&gt;,
    pub random_seed: [u8; 32],
}

pub trait CommitmentScheme {
    fn commit(&amp;self, message: &amp;[u8], randomness: &amp;[u8]) -&gt; BitCommitment;
    fn verify(&amp;self, commitment: &amp;BitCommitment, message: &amp;[u8]) -&gt; bool;
    fn reveal(&amp;self, commitment: &amp;BitCommitment, randomness: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;
}
</code></pre>
<br/>
<p>#### 3.8.2 中奖序号生成</p>
<p>- 基于投票数据的确定性中奖序号生成</p>
<p>- 支持多等级中奖序号分配</p>
<p>- 确保中奖序号的唯一性和公平性</p>
<br/>
<h3>3.9 WebAssembly服务器模块</h3>
<p>#### 3.9.1 决策投票生命周期管理</p>
<pre><code>
pub enum DecisionVoteStatus {
    Created,
    Active,
    Paused,
    Closed,
    Tallied,
}

pub struct DecisionVoteLifecycle {
    pub decision_vote_id: String,
    pub status: DecisionVoteStatus,
    pub created_at: u64,
    pub start_time: u64,
    pub end_time: u64,
    pub total_preference_votes: u64,
    pub preference_range: (i32, i32), // 偏好值范围
    pub nft_contract_address: Option&lt;String&gt;, // NFT合约地址
    pub lottery_tiers: Option&lt;Vec&lt;LotteryTierConfig&gt;&gt;, // 抽奖等级配置
}
</code></pre>
<br/>
<p>#### 3.9.2 区块链交互接口</p>
<p>- 智能合约调用封装</p>
<p>- 偏好投票交易状态监控</p>
<p>- 决策结果事件监听和处理</p>
<p>- 代币余额查询和验证</p>
<p>- NFT所有权验证</p>
<p>- 错误处理和重试机制</p>
<br/>
<p>#### 3.9.3 存储适配器抽象层</p>
<pre><code>
pub trait StorageAdapter {
    async fn store(&amp;self, key: &amp;str, value: &amp;[u8]) -&gt; Result&lt;String, Error&gt;;
    async fn retrieve(&amp;self, key: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
    async fn verify(&amp;self, key: &amp;str, hash: &amp;[u8]) -&gt; Result&lt;bool, Error&gt;;
    async fn store_nft_metadata(&amp;self, metadata: &amp;NFTMetadata) -&gt; Result&lt;String, Error&gt;;
    async fn retrieve_nft_metadata(&amp;self, uri: &amp;str) -&gt; Result&lt;NFTMetadata, Error&gt;;
}
</code></pre>
<br/>
<h3>3.10 区块链智能合约</h3>
<p>#### 3.10.1 代币合约接口</p>
<pre><code>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct TokenBalance {
    pub address: String,
    pub balance: Uint128,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum TokenQueryMsg {
    Balance { address: String },
    TokenInfo {},
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct TokenInfoResponse {
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub total_supply: Uint128,
}
</code></pre>
<br/>
<p>#### 3.10.2 NFT合约接口</p>
<pre><code>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum NFTExecuteMsg {
    Mint {
        token_id: String,
        owner: String,
        token_uri: String,
        extension: Option&lt;Extension&gt;,
    },
    TransferNft {
        recipient: String,
        token_id: String,
    },
    UpdateMetadata {
        token_id: String,
        token_uri: String,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum NFTQueryMsg {
    OwnerOf { token_id: String },
    TokenInfo { token_id: String },
    NumTokens {},
    AllTokens { start_after: Option&lt;String&gt;, limit: Option&lt;u32&gt; },
}
</code></pre>
<br/>
<p>#### 3.10.3 投票合约扩展</p>
<pre><code>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct DecisionVote {
    pub title: String,
    pub description: String,
    pub min_preference: i32,
    pub max_preference: i32,
    pub start_time: u64,
    pub end_time: u64,
    pub is_active: bool,
    pub result_hash: String,
    pub creator: Addr,
    pub is_lottery: bool, // 标识是否为抽奖活动
    pub nft_contract_address: Option&lt;String&gt;, // NFT合约地址
    pub lottery_tiers: Option&lt;Vec&lt;LotteryTierConfig&gt;&gt;, // 抽奖等级配置
    pub min_token_requirement: Uint128, // 创建投票项目所需的最小代币数量
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    CreateDecisionVote {
        title: String,
        description: String,
        min_preference: i32,
        max_preference: i32,
        start_time: u64,
        end_time: u64,
        max_votes: Option&lt;u64&gt;,
        min_votes: Option&lt;u64&gt;,
        is_lottery: bool,
        nft_contract_address: Option&lt;String&gt;,
        lottery_tiers: Option&lt;Vec&lt;LotteryTierConfig&gt;&gt;,
        min_token_requirement: Uint128,
    },
    SubmitPreferenceCommitment {
        decision_vote_id: String,
        commitment: String,
        nft_proof: NFTProof, // NFT所有权证明
    },
    RevealPreferenceVote {
        decision_vote_id: String,
        preference: i32,
        randomness: String,
    },
    SetLotteryTiers {
        decision_vote_id: String,
        tiers: Vec&lt;LotteryTierConfig&gt;,
    },
    AssignWinningNumbers {
        decision_vote_id: String,
        winning_numbers: Vec&lt;WinningNumber&gt;,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct NFTProof {
    pub token_id: String,
    pub nft_contract_address: String,
    pub owner_signature: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct WinningNumber {
    pub participant_index: u64,
    pub winning_number: u64,
    pub tier_id: u32,
}
</code></pre>
<br/>
<h3>3.11 客户端SDK</h3>
<p>#### 3.11.1 投票项目管理（作为NFT属性接口）</p>
<pre><code>
// 投票项目相关接口作为 NFT 管理的一部分暴露，仅配置 NFT 类型的全局参数
class VotingProjectInterface {
    async configureForNftType(nftType: string, params: NftGlobalVotingParams): Promise&lt;string&gt;; // 返回配置版本/CID
    async getConfigByNftType(nftType: string): Promise&lt;NftGlobalVotingParams&gt;;
}

interface NftGlobalVotingParams {
    title?: string;              // 可选，展示用
    description?: string;        // 可选，展示用
    minPreference: number;
    maxPreference: number;
    commitStartTime: number;
    commitEndTime: number;
    revealStartTime: number;
    revealEndTime: number;
    isLottery?: boolean;
    lotteryTiers?: LotteryTierConfig[]; // 明细入IPFS，链上仅存CID/摘要
}

interface LotteryTierConfig {
    tierId: number;
    tierName: string;
    prizeDescription: string;
    winnerCount: number;
}
</code></pre>
<br/>
<p>#### 3.11.2 NFT管理接口</p>
<pre><code>
class NFTManager {
    async createVotingNFT(metadata: NFTMetadata): Promise&lt;string&gt;;
    async verifyOwnership(userAddress: string, tokenId: string): Promise&lt;boolean&gt;;
    async assignWinningNumber(tokenId: string, winningNumber: number): Promise&lt;void&gt;;
    async getNFTMetadata(tokenId: string): Promise&lt;NFTMetadata&gt;;
}

interface NFTMetadata {
    name: string;
    description: string;
    image: string;
    attributes: NFTAttribute[];
    votingProjectId: string;
    lotteryTier?: LotteryTier;
    winningNumber?: number;
}
</code></pre>
<br/>
<p>#### 3.11.3 代币验证接口</p>
<pre><code>
class TokenVerifier {
    async verifyTokenHolding(userAddress: string, minAmount: string): Promise&lt;boolean&gt;;
    async getTokenBalance(userAddress: string): Promise&lt;string&gt;;
    async getTokenInfo(): Promise&lt;TokenInfo&gt;;
}

interface TokenInfo {
    name: string;
    symbol: string;
    decimals: number;
    totalSupply: string;
}
</code></pre>
<br/>
<h3>3.12 存储策略模块</h3>
<p>#### 3.12.1 存储边界澄清</p>
<p>- 主要存储：IPFS。存放投票决策的详细数据（承诺/揭示明细、参与者、计算过程与证明、完整配置版本等）。</p>
<p>- 链上最小化：仅记录账户与NFT的关联信息、结果摘要/哈希/CID、必要索引与审计事件。</p>
<p>- 单一真实源（Single Source of Truth）：以 IPFS 的 `CID/版本` 作为配置与明细的唯一真实源；链上仅做完整性校验与可验证引用，避免状态膨胀与重复来源。</p>
<br/>
<p>#### 3.12.2 NFT元数据与配置</p>
<p>- IPFS存储NFT元数据与投票相关配置版本；链上保存其CID/哈希用于完整性验证与检索。</p>
<br/>
<h2>4. 数据流设计</h2>
<br/>
<h3>4.1 NFT类型创建和应用场景控制流程</h3>
<p>1. 用户验证$LUCKEE代币持有量</p>
<p>2. 创建NFT类型定义，包括应用场景配置</p>
<p>3. 设置NFT类型的全局状态变量</p>
<p>4. 配置比特承诺状态控制规则</p>
<p>5. 存储NFT类型信息到区块链</p>
<p>6. 返回NFT类型ID和配置信息</p>
<br/>
<h3>4.2 NFT分发替代用户注册流程</h3>
<p>1. 用户请求参与特定应用场景</p>
<p>2. 系统验证用户资格（代币持有量、地理位置等）</p>
<p>3. 根据NFT类型分发相应的NFT</p>
<p>4. 更新NFT全局状态变量</p>
<p>5. 记录NFT分发信息到区块链</p>
<p>6. 返回NFT ID和参与确认</p>
<br/>
<h3>4.3 基于NFT状态的比特承诺控制流程</h3>
<p>1. 用户提交偏好投票承诺</p>
<p>2. 系统查询NFT全局状态变量</p>
<p>3. 验证NFT状态是否允许承诺操作</p>
<p>4. 执行承诺操作并更新NFT状态</p>
<p>5. 触发状态变更钩子</p>
<p>6. 记录状态变更到区块链</p>
<br/>
<h3>4.4 投票参与流程</h3>
<p>1. 用户验证NFT类型和所有权</p>
<p>2. 系统检查NFT状态是否允许投票</p>
<p>3. 提交偏好投票承诺</p>
<p>4. 验证投票资格和NFT状态</p>
<p>5. 记录投票参与信息</p>
<p>6. 更新NFT状态和投票统计</p>
<br/>
<h3>4.5 抽奖结果计算流程</h3>
<p>1. 收集所有参与者的随机数</p>
<p>2. 根据NFT类型配置分配中奖者</p>
<p>3. 为每个中奖者分配中奖序号</p>
<p>4. 更新NFT元数据中的中奖信息</p>
<p>5. 更新NFT全局状态变量</p>
<p>6. 生成抽奖结果证明</p>
<br/>
<h3>4.6 多目标选择流程</h3>
<p>1. **会话创建**：创建多目标选择会话，设置参与者数量和目标数量</p>
<p>2. **NFT分发**：参与者通过NFT类型验证身份，获得参与NFT</p>
<p>3. **值选择阶段**：每个参与者选择k个值，反映对中奖序号的偏好</p>
<p>4. **承诺阶段**：iAgent基于NFT状态自动生成承诺并存储到IPFS和区块链</p>
<p>5. **揭示阶段**：iAgent基于NFT状态自动揭示所有参与者的真实值</p>
<p>6. **中奖计算**：基于所有参与者的值计算k个不同的中奖序号</p>
<p>7. **结果验证**：验证计算过程的正确性和结果的唯一性</p>
<p>8. **状态更新**：更新NFT全局状态变量</p>
<br/>
<p>#### 4.6.1 多目标选择算法</p>
<p>- **基准序号计算**：A1 = (∑v_{i1}) mod n + 1</p>
<p>- **偏移序号计算**：Aj = (A_{j-1} + Δj) mod n，确保唯一性</p>
<p>- **防冲突机制**：通过循环递增确保所有中奖序号互不相同</p>
<p>- **支持策略选择**：参与者可根据策略选择不同的值组合</p>
<p>- **NFT状态集成**：算法执行过程中实时更新NFT状态变量</p>
<br/>
<h2>5. 接口设计</h2>
<br/>
<h3>5.1 RESTful API扩展</h3>
<pre><code>
// NFT类型管理
POST /api/nft-types - 创建NFT类型
GET /api/nft-types/:id - 获取NFT类型信息
PUT /api/nft-types/:id/config - 更新NFT类型配置
DELETE /api/nft-types/:id - 删除NFT类型

// NFT分发管理
POST /api/nft-distribution - 分发NFT
GET /api/nft-distribution/:nftType - 获取NFT分发状态
PUT /api/nft-distribution/:id/status - 更新分发状态
POST /api/nft-distribution/batch - 批量分发NFT

// NFT状态管理
GET /api/nft-states/:nftType - 获取NFT全局状态
PUT /api/nft-states/:nftType - 更新NFT状态
POST /api/nft-states/:nftType/transitions - 执行状态转换
GET /api/nft-states/:nftType/history - 获取状态变更历史

// NFT类型投票配置（投票项目属性接口）
POST /api/nft-voting-config - 创建/更新NFT类型全局参数配置（返回CID/版本）
GET /api/nft-voting-config/:nftType - 获取NFT类型全局参数配置
PUT /api/nft-voting-config/:nftType/tiers - 设置抽奖等级（配置写入IPFS，链上仅存CID）
POST /api/nft-voting-config/:nftType/winning-numbers - 分配中奖序号（结果摘要上链）

// NFT管理
POST /api/nfts - 创建投票NFT
GET /api/nfts/:tokenId - 获取NFT信息
PUT /api/nfts/:tokenId/winning-number - 更新中奖序号
GET /api/nfts/verify/:tokenId/:owner - 验证NFT所有权

// 代币验证
GET /api/tokens/balance/:address - 查询代币余额
GET /api/tokens/verify/:address/:amount - 验证代币持有量

// 多目标选择管理
POST /api/multi-target/sessions - 创建多目标选择会话
GET /api/multi-target/sessions/:id - 获取会话信息
PUT /api/multi-target/sessions/:id/status - 更新会话状态
POST /api/multi-target/sessions/:id/participants - 添加参与者
POST /api/multi-target/sessions/:id/commitments - 提交承诺
POST /api/multi-target/sessions/:id/reveals - 提交揭示
GET /api/multi-target/sessions/:id/winners - 获取中奖结果
GET /api/multi-target/sessions/:id/verification - 验证会话完整性
</code></pre>
<br/>
<h3>5.2 智能合约事件扩展</h3>
<pre><code>
// NFT类型相关事件
Response::new()
    .add_attribute("action", "nft_type_created")
    .add_attribute("nft_type", nft_type)
    .add_attribute("creator", creator)
    .add_attribute("application_category", category)

Response::new()
    .add_attribute("action", "nft_type_config_updated")
    .add_attribute("nft_type", nft_type)
    .add_attribute("config_version", version.to_string())

// NFT分发相关事件
Response::new()
    .add_attribute("action", "nft_distributed")
    .add_attribute("nft_type", nft_type)
    .add_attribute("recipient", recipient)
    .add_attribute("distribution_strategy", strategy)

Response::new()
    .add_attribute("action", "batch_nft_distribution")
    .add_attribute("nft_type", nft_type)
    .add_attribute("batch_size", batch_size.to_string())
    .add_attribute("distribution_id", distribution_id)

// NFT状态相关事件
Response::new()
    .add_attribute("action", "nft_state_updated")
    .add_attribute("nft_type", nft_type)
    .add_attribute("variable_name", variable_name)
    .add_attribute("new_value", new_value)
    .add_attribute("state_version", version.to_string())

Response::new()
    .add_attribute("action", "nft_state_transition")
    .add_attribute("nft_type", nft_type)
    .add_attribute("from_state", from_state)
    .add_attribute("to_state", to_state)
    .add_attribute("transition_trigger", trigger)

// 比特承诺状态控制事件
Response::new()
    .add_attribute("action", "commitment_state_checked")
    .add_attribute("nft_type", nft_type)
    .add_attribute("user_address", user_address)
    .add_attribute("commitment_allowed", allowed.to_string())

Response::new()
    .add_attribute("action", "commitment_state_updated")
    .add_attribute("nft_type", nft_type)
    .add_attribute("user_address", user_address)
    .add_attribute("commitment_id", commitment_id)

// 代币相关事件
Response::new()
    .add_attribute("action", "token_balance_verified")
    .add_attribute("user_address", user_address)
    .add_attribute("balance", balance.to_string())
    .add_attribute("min_requirement", min_requirement.to_string())

// NFT相关事件
Response::new()
    .add_attribute("action", "voting_nft_created")
    .add_attribute("token_id", token_id)
    .add_attribute("voting_project_id", voting_project_id)
    .add_attribute("owner", owner)

// 抽奖等级事件
Response::new()
    .add_attribute("action", "lottery_tiers_set")
    .add_attribute("project_id", project_id)
    .add_attribute("tier_count", tier_count.to_string())

// 中奖序号事件
Response::new()
    .add_attribute("action", "winning_numbers_assigned")
    .add_attribute("project_id", project_id)
    .add_attribute("winner_count", winner_count.to_string())

// 多目标选择事件
Response::new()
    .add_attribute("action", "multi_target_session_created")
    .add_attribute("session_id", session_id)
    .add_attribute("participant_count", participant_count.to_string())
    .add_attribute("target_count", target_count.to_string())

Response::new()
    .add_attribute("action", "multi_target_commitment_submitted")
    .add_attribute("session_id", session_id)
    .add_attribute("participant_id", participant_id.to_string())
    .add_attribute("commitment_hash", commitment_hash)

Response::new()
    .add_attribute("action", "multi_target_reveal_submitted")
    .add_attribute("session_id", session_id)
    .add_attribute("participant_id", participant_id.to_string())
    .add_attribute("reveal_hash", reveal_hash)

Response::new()
    .add_attribute("action", "multi_target_winners_calculated")
    .add_attribute("session_id", session_id)
    .add_attribute("winners", winners.join(","))
    .add_attribute("calculation_proof", calculation_proof)
</code></pre>
<br/>
<h2>6. 安全设计</h2>
<br/>
<h3>6.1 NFT类型安全机制</h3>
<p>- 验证NFT类型创建者权限</p>
<p>- 防止NFT类型配置被恶意修改</p>
<p>- 确保NFT类型之间的隔离性</p>
<br/>
<h3>6.2 NFT分发安全机制</h3>
<p>- 验证用户分发资格</p>
<p>- 防止NFT重复分发</p>
<p>- 确保分发过程的公平性</p>
<br/>
<h3>6.3 NFT状态安全机制</h3>
<p>- 验证状态变更权限</p>
<p>- 防止状态变量被恶意修改</p>
<p>- 确保状态转换的原子性</p>
<br/>
<h3>6.4 代币权限控制</h3>
<p>- 验证用户代币持有量</p>
<p>- 防止代币余额操纵</p>
<p>- 支持代币锁定机制</p>
<br/>
<h3>6.5 NFT安全机制</h3>
<p>- 验证NFT所有权</p>
<p>- 防止NFT重复使用</p>
<p>- 确保NFT与投票项目的关联性</p>
<br/>
<h3>6.6 抽奖公平性保障</h3>
<p>- 中奖序号生成算法透明</p>
<p>- 防止中奖结果操纵</p>
<p>- 支持结果验证和审计</p>
<br/>
<h3>6.7 多目标选择安全机制</h3>
<p>- **比特承诺保护**：确保参与者选择值在揭示前不可见</p>
<p>- **NFT状态验证**：基于NFT状态变量验证操作权限</p>
<p>- **AI代理授权**：验证AI代理的操作权限和身份</p>
<p>- **防重放攻击**：使用时间戳和唯一标识防止重复操作</p>
<p>- **数据完整性**：IPFS和区块链双重验证确保数据不被篡改</p>
<p>- **计算验证**：提供完整的计算过程证明，支持第三方验证</p>
<p>- **状态一致性**：确保NFT状态在所有操作中保持一致</p>
<br/>
<h3>6.8 威胁模型与时序约束（补充）</h3>
<p>- 时间来源：以链上区块时间为准；所有窗口参数（commitStart/End, revealStart/End）以区块时间校验。</p>
<p>- 迟到/缺席策略：揭示阶段未揭示的承诺视为无效，不参与聚合；可配置宽限期（gracePeriod）。</p>
<p>- 前置承诺防操纵：通过承诺-揭示避免在他人揭示后调整输入；列级域分离与盐防止重放与碰撞构造。</p>
<p>- DoS/拖延：iAgent 自动化应支持超时重试与批处理；对单参与者延迟不产生全局阻塞。</p>
<p>- 重放/重用：承诺绑定会话上下文与NFT类型/状态哈希，禁止跨会话复用。</p>
<br/>
<h2>7. 性能优化</h2>
<br/>
<h3>7.1 NFT类型性能优化</h3>
<p>- **NFT类型缓存**：缓存NFT类型定义和配置，减少重复查询</p>
<p>- **类型预加载**：预加载常用NFT类型，提高响应速度</p>
<p>- **类型索引优化**：为NFT类型建立高效索引，支持快速查找</p>
<br/>
<h3>7.2 NFT分发性能优化</h3>
<p>- **批量分发处理**：支持批量NFT分发，提高处理效率</p>
<p>- **分发队列优化**：优化分发队列管理，支持高并发分发</p>
<p>- **资格验证缓存**：缓存用户资格验证结果，减少重复验证</p>
<br/>
<h3>7.3 NFT状态管理性能优化</h3>
<p>- **状态变更批处理**：支持批量状态变更，减少网络往返</p>
<p>- **状态缓存策略**：实现多层状态缓存，提高状态查询性能</p>
<p>- **状态同步优化**：优化状态同步机制，确保状态一致性</p>
<br/>
<h3>7.4 NFT批量操作</h3>
<p>- 支持批量NFT创建</p>
<p>- 批量中奖序号分配</p>
<p>- 优化存储和查询性能</p>
<br/>
<h3>7.5 代币查询优化</h3>
<p>- 缓存代币余额信息</p>
<p>- 批量代币验证</p>
<p>- 减少区块链查询次数</p>
<br/>
<h3>7.6 多目标选择性能优化</h3>
<p>- **并行处理**：支持批量承诺和揭示操作，提高处理效率</p>
<p>- **智能缓存**：缓存会话状态和参与者信息，减少重复查询</p>
<p>- **异步计算**：中奖序号计算异步执行，不阻塞其他操作</p>
<p>- **批量验证**：支持批量承诺验证，减少网络往返次数</p>
<p>- **连接池管理**：优化IPFS和区块链连接，提高并发性能</p>
<p>- **NFT状态优化**：基于NFT状态变量优化计算流程</p>
<br/>
<h2>8. 部署架构</h2>
<br/>
<h3>8.1 智能合约部署</h3>
<p>- 代币合约部署</p>
<p>- NFT合约部署</p>
<p>- 投票合约部署</p>
<p>- **NFT类型管理合约部署**</p>
<p>- **NFT状态管理合约部署**</p>
<p>- 合约间交互配置</p>
<br/>
<h3>8.2 前端集成</h3>
<p>- NFT钱包集成</p>
<p>- 代币余额显示</p>
<p>- **NFT类型管理界面**</p>
<p>- **NFT分发管理界面**</p>
<p>- **NFT状态监控界面**</p>
<p>- 投票资格验证界面</p>
<p>- 抽奖等级管理界面</p>
<br/>
<h3>8.3 监控和维护</h3>
<p>- **NFT类型监控**：监控NFT类型的创建、配置和状态</p>
<p>- **NFT分发监控**：监控NFT分发过程和成功率</p>
<p>- **NFT状态监控**：监控NFT状态变更和一致性</p>
<p>- 系统性能监控</p>
<p>- 安全事件监控</p>
<br/>
<p>这个概要设计说明书描述了完整的系统架构，包含NFT类型管理、NFT分发管理、NFT状态管理等核心功能模块，为系统的完整实现提供了技术指导。系统通过NFT类型控制不同应用场景，使用NFT分发替代用户注册功能，并通过NFT全局状态变量控制比特承诺功能，完全符合新的架构设计理念。</p>
<br/>
<p>---</p>
<br/>
<p>**文档编制日期**：2025年8月</p>
<p>**文档编制人**：luckeeDAO技术评估团队</p>
<p>**文档审核人**：luckeeDAO管理委员会</p>
</body>
</html>